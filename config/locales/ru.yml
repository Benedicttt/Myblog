ru:
  mac:
    how_install: "- как установить как основную ОС"
    ruby:
      recommend: "Я рекомендую для %{platform} установить RVM - ruby version manager. Для этого потребуется:"
      line1: 1) Откройте терминал в %{platform}. Добавить ключ GPG <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</pre>
      line2: 2) Выполните команду <pre class="code code-shell-cmd" title="triple click to select command">\curl -sSL https://get.rvm.io | bash -s stable</pre>
      line3: 3) После установки "rvm" нужно перезапустить терминал в оболочке
      line4: 4) Нам нужно установить версию руби 2.7, для этого в терминале набираем и выполняем команду <pre class="code code-shell-cmd" title="triple click to select command">rvm install 2.7</pre>
      line5: "5) После долгой установки, так же в терминале можно посмотреть версию, набрав и выполнив команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">ruby -v</pre>"
    java:
      header: Установка языка программирования Java на MacOsX
      line1: 1) Откройте терминал в MacOsX и обновите пакеты командой
      line2: 2) Выполните команду
      line3: Если по какойто причине у вас возникли проблемы с установкой , перейдите по ссылке и попробуте по этому
      line4: "3) После установки, можно посмотреть версию, набрав и выполнив команду"
    js:
      header: Установка языка программирования NodeJS на MacOsX
      line1: 1) Откройте терминал в MacOsX и обновите пакеты с помощью команды
      line2: 2) Запустите команду
      line3: Если по какой-то причине у вас возникли проблемы с установкой, перейдите по ссылке и попробуйте
      line4: 3) После установки "ноды" необходимо перезапустить терминал в оболочке
      line5: 4) После установки и перезапуска терминала вы можете увидеть версию, набрав и выполнив команду
  fedora:
    snap: Все что нужно устанавливать через SNAP
    no_snap: Все что нужно устанавливать не через SNAP
    how_install: "- как установить как основную ОС или рядом с Windows 10"
    java:
      header: Установка языка программирования Java на %{platform}
      line1: "1) Откройте терминал в Fedora и наберите следующую команду"
      line2: "2) В результате будет отображен списко всех версий JDK(Java Development Kit), вам нужно выбрать ту в зависимости которая вам нужна, например"
      line3: "Если по какойто причине у вас возникли проблемы с установкой , перейдите по ссылке и попробуте по этому"
      line4: "3) После установки, можно посмотреть версию, набрав и выполнив команду"
    js:
      header: Установка языка программирования NodeJs на %{platform}
      step1: Можно установить через Snap
      line1: "1) Откройте терминал в Fedora и наберите следующую команду"
      line2: "2) В результате будет отображен списко всех версий NodeJS, вам нужно выбрать ту в зависимости которая вам нужна, например"
      line3: "Если по какойто причине у вас возникли проблемы с установкой , перейдите по ссылке и попробуте по этому"
      line4: "3) После установки, можно посмотреть версию, набрав и выполнив команду"
    ruby:

  ubuntu:
    snap: все что необходимо установить из SNAP
    no_snap: все что необходимо устанавливать не по SNAP
    how_install: "- как установить как основную ОС или рядом с Windows 10"
    java:
      header: Установка языка программирования Java на %{platform}
      line1: "1) Откройте терминал в Ubuntu и наберите следующую команду"
      line2: "2) В результате будет отображен списко всех версий JDK(Java Development Kit), вам нужно выбрать ту в зависимости которая вам нужна, например"
      line3: "Если по какойто причине у вас возникли проблемы с установкой , перейдите по ссылке и попробуте по этому"
      line4: "3) После установки, можно посмотреть версию, набрав и выполнив команду"
    js:
      header: Установка языка программирования NodeJs на %{platform}
      step1: Может быть установлен из Snap
      line1: "1) Откройте терминал в Ubuntu и наберите следующую команду"
      line2: "2) В результате будет отображен списко всех версий NodeJS, вам нужно выбрать ту в зависимости которая вам нужна, например"
      line3: "Если по какойто причине у вас возникли проблемы с установкой , перейдите по ссылке и попробуте по этому"
      line4: "3) После установки, можно посмотреть версию, набрав и выполнив команду"
    ruby:

  windows:
    how_install: "- как установить как основную ОС"
    ruby:
      header: Установка языка программирования Ruby на %{platform}
      line1: "1) Переходим по <a href='https://rubyinstaller.org/downloads/'  target='_blank'>ссылке</a> и скачиваем файл инсталяции - желательно версию 2.7.3-1, примеры, указанные на сайте, будут на этой версии Ruby"
      line2: "2) Нажимаем комбинацию клавишь <strong>WIN + R</strong> и вводим команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">cmd</pre>- откроется командная строка"
      line3: "3) Нужно проверить версию Ruby которая установилась, для этого указываем команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">ruby -v</pre>"
    java:
      header: Установка языка программирования Java на %{platform}
      line1: "1) Переходим по ссылке и скачиваем файл инсталяции для"
      line2: ", и устанавливаем ПО. И та и та версии нам подойдут в дальнейшем"
      line3: "2) Нажимаем комбинацию клавишь <strong>WIN + R</strong> и вводим команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">cmd</pre>- откроется командная строка"
      line4: "3) Нужно проверить версию Java которая установилась, для этого указываем команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">java -version</pre>"
    js:
      header: Установка языка программирования NodeJs на %{platform}
      line1: 1) Переходим по
      line2: ссылке и скачиваем файл инсталяции и устанавливаем с него ПО
      line3: "2) Нажимаем комбинацию клавишь <strong>WIN + R</strong> и вводим команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">cmd</pre>- откроется командная строка"
      line4: "3) Нужно проверить установился ли правильно NodeJS, для этого указываем команду <pre class=\"code code-shell-cmd\" title=\"triple click to select command\">node -v</pre>"
    head: Полезный софт и ссылки для %{platform} который поможет при тестировании и не только
    git: "- распределённая система управления версиями."
    putty: "- свободно распространяемый клиент для различных протоколов удалённого доступа, включая SSH, Telnet, rlogin."
    fast_stone: "- очень крутой редактор для скриншотов, где можно подписывать и рисовать"
    sys:
      env1: "Как выставить"
      env2: "системные переменные"
      env3: (нужно для JAVA)
    docker: "- платформа для контейнеризации"
    postman: "- программа для работы с апи запросами"
    zoom: "- программа для видеоконференций"
    ssh: "- описание того как работать с приватными и публичными ключами ssh, генерация нормального rsa (ssh-keygen -t rsa -b 4096)"
    editor: редактор для %{platform}
    zsh: "- это платформа с открытым исходным кодом для управления конфигурацией ZSH, управляемая сообществом. Груба говоря надстройка на bash. Плагин gnzh."
    terminator: " - очень удобный терминал, лучше чем дефолтный на Ubuntu"
    terminator2: " - очень удобный терминал, лучше чем дефолтный на MacOs"
    libbre: " - все что есть в Microsoft office но только бесплатно"
    homebrew: " - для установки стороних пакетов через терминал"
    appstorrent: " - очень много полезного софта для mac"
    paw: " - программа для работы с апи запросами, альтернатива Postman"
    vpn: " - программа для VPN подключения"

  see_version: "В результате отобразится версия %{lang}:"
  ide: Установка IDE для разработки (редактор)
  feature: В дальнейшем будет показан код в редакторе %{ide}, вы же можете использовать любой редактор который вам по душе.
  count: "Есть много хороших редакторов которыми пользуються для написания кода для %{lang}, некоторые из них:"
  step:
    gui: Способ как написать простые GUI тесты
    back: Способ как написать простые API тесты
    mobile: Способ как написать простые Mobile тесты
  example: Пример
  outcome: Итог
  guide: гайду
  or: или
  or_or: версии, или для
  outcome_describe: "Когда у вас есть установленый язык программирования на ОС и есть хороший редактор для вашего нового проекта, вы можете смело пробовать свои силы для написания простого или сложного теста, но для начала выбирете раздел:"

  loader: Загрузка ...
  hello: Hello world! RU
  header: RU
  language_en: Английский
  language_ru: Русский
  main: На главную
  about: О блоге
  about_describe: "<strong>Цель блога помочь начинающим (или неначинающим) QA разобратся в фундаментальных понятиях, терминах и азах для того что бы начать автоматизировать ПО самому.</strong>"
  author: С.Киевский
  gui: "<strong>GUI (Graphical User Interface) или ГИП (графический интерфейс пользователя)</strong> — это одна из разновидностей пользовательских интерфейсов, элементы которого выполнены в виде графических изображений. То есть все основные объекты, присутствующие в этом интерфейсе — иконки, функциональные кнопки, объекты меню и т.д. — выполнены в виде изображений. Если сравнить GUI с обычной командной строкой, то в первом варианте перед пользователем открывается полный доступ к абсолютно всем элементам, который он видит на дисплее. Реализовать этот доступ можно с использованием разных устройств ввода: оптической мыши, трекбола, клавиатуры, джойстика и пр. Обычно в GUI каждый графический объект передает смысл функции с помощью понятного образа, чтобы пользователю было проще разобраться с определенным программным обеспечением и легче взаимодействовать с ОС в целом. Но важно понимать, что GUI — это лишь составная часть графического интерфейса. Функционирует он на уровне визуализации данных и таким же образом взаимодействует с пользователем."
  cli: <strong>CLI - command line interface</strong> - интерфейс командной строки, то есть случай когда мы выполняем какое-то дествие с помощью терминала.
  apis:
    line1: "<strong>API — это Application Programming Interface</strong>, или программный интерфейс приложения, с помощью которого одна программа может взаимодействовать с другой. API позволяет слать информацию напрямую из одной программы в другую, минуя интерфейс взаимодействия с пользователем."
    line2: <strong>Как это работает?</strong> Представьте, что вы сидите в ресторане, выбираете блюдо в меню. Подходит официант, и вы делаете заказ. Официант передаёт ваш заказ на кухню, там происходит магия, и через некоторое время перед вами появляется готовое блюдо. API работает по такому же принципу — принимает ваш запрос, передаёт информацию системе, обрабатывает её и возвращает ответ.
    line3: <strong>Какие бывают?</strong> API может быть внутренним, частным — когда программные компоненты связаны между собой и используются внутри системы. А может быть открытым, публичным — в таком случае он позволяет внешним пользователям или другим программам получать информацию, которую можно интегрировать в свои приложения.
    line4: Чтобы программам общаться между собой, их API нужно построить по единому стандарту. Одним из них является REST — стандарт архитектуры взаимодействия приложений и сайтов, использующий протокол HTTP. Особенность REST в том, что сервер не запоминает состояние пользователя между запросами. Иными словами, идентификация пользователя (авторизационный токен) и все параметры выполнения операции передаются в каждом запросе. Этот подход настолько прост и удобен, что почти вытеснил все другие.
  mobile: Все тоже самое что в GUI, только особиностью смартфонов есть то что их много и у каждого свое разрешение экрана. У них есть свои приложения под свои экраны и отображения сайта в мобильной версии отличается от десктопной версии. Из-за этого, тестирование мобильных версий и ПО на мобилках считается одним из самых сложных.
  installs:
    install: Установить
    windows: на Виндовс
    linux: на Ubuntu
    fedora: на Fedora
    mac: на MacOs
  describe:
    header: Про тестирование простыми словами
    tabs_and_page:

      tab_what_is_this_testing:
        tab: Что такое тестирование ПО(Программного обеспечения)?
        describe:
          line1: Тестирование программного обеспечения - это процесс проверки соответствия требований от заказчика и того что написали программисты.
          line2: Процесc когда мы проверяем как должно быть и как есть на самом деле, мы и называем - тестированием.
          line3: У каждого тестирования есть жизненый цыкл (ЖЦ). Не путайте с ЖЦ разработки или методологией разработки.
          line4: ЖЦ тестирования это этапы от самого начала тестирования и нахождение ошибок (багов), не соответствий и т. д., до его окночания, когда все ошибки исправлены - когда продукт соответсвует техническому заданию (ТЗ) от заказчика.
          line5: Чаще всего в процессе тестирования возникают дополнения к ТЗ, так как некоторые вещи, например технически нельзя реализовать и находятся другие варианты реализации для того что бы задание из ТЗ выполнялось.
          line6: "Давайте расмотри, так что же такое \"Жизненный цыкл в тестировании\" и его этапы:"
          line7: 1. <em>Планирование и анализ требований</em> - вы просто смотрите, что от вас хотят и говорите \"мне на это потребуется день два на разбор и просомтреть что готово а что нет в ПО\". <p>
          line8: 2. <em>Уточнение критериев приемки</em> - после того как вы прочитали и глянули сырой функционал вы обязательно уточняете минимальные требования для работоспособности ПО. Шаг обязателен.<p>
          line9: 3. <em>Уточнение стратегии тестирования</em> - в принцыпе без нее можно обойтись. Но важно понимать что стратегия в тестировании это - организация самого процесса тестирования при условии ограниченых ресурсов. По этому было бы неплохо понять что вообще из ресурсов имеется. Плюс к этому стратегия тестирования нужна для того что бы каждый из участников понимал какова роль тестирования в проекте, что тестируется, как тестируется и что бы у всех было реальное понимание в ожидании того что вообще происходит в контроле качества.<p>
          line10: "4. <em>Разработка тестовой документации</em> - это то самое что многие автоматизаторы не любят, это написание тест-кейсов. На данной стадии происходит разработка, доработка, тестовой документации: тест-кейс, тест-сьют, тест-планы<p>"
          line11: 5. <em>Выполнение тест-кейсов и Фиксация найденных дефектов</em> - говорит само за себя. Записали пошаговое выполнения какого то маленького кусочка ПО (тест-кейса) и начали его проверять. Опа! Выполненая проверка с тест-кейса не соответсвует тому что есть в ПО на самом деле - пишем ошибку в багтрекинг (платформа фиксации какого либо бага, таски, епика и т. д.)<p>
          line12: "6. <em>Анализ результатов тестирования и Отчетность - про это я напишу как пишут в просторах инета: формулируемые выводы зависят от плана тестирования и критериев приемки и служат основой для стадий 1,2,3 следующей итерации.</em>"
          line13: <em>Планирование (Planning) — непрерывный процесс принятия управленческих решений и методической организации усилий по их реализации с целью обеспечения качества некоторого процесса на протяжении длительного периода времени. По факту это собираются ваши коллеги и обсуждают какуюто доработку - вы в этом случаи, основываясь на своем опыте, говорите что вам например потребуется два дня на тестирование даной доработки, когда она будет готова.<br><br>Отчётность (reporting) - это сбор и распространение информации о результатах работы (включая текущий статус, оценку прогресса и прогноз развития ситуации).</em></blockquote>
          line14: "Звучит все ужасно и непонятно - но это только пока, когда начнется практика, для Вас все что написано выше, станет привычным и понятным. Поехали дальше!"
          line15: Так как в ЖЦ тестирования есть множество подходов, в самом тестировании вывели <a href="#" id="type_testing" onclick=clickTab("#types-qa")>Виды тестирования</a>

      tab_testing_types:
        tab: Виды тестирования
        describe:
          head: "Необходимо подсветить главные типы тетсирования:"
          functional_testing: Функциональное тестирование
          functional_testing_describe: Проверка функциональности (тестирование методом «черного ящика») – проверка соответствия программного обеспечения требованиям, заявленным в спецификации. Может проводиться как полное тестирование заявленной функциональность, так и проверка только базовой функциональности. Тестирование «белого ящика» (white box) тестирование на соответствие программного продукта требованиям со знанием внутренней структуры реализации системы (есть в наличии исходный код и технические спецификации). Тестирование «черного ящика» (black box) тестирование на соответствие программного продукта требованиям без знания внутренней структуры реализации системы.
          system_testing: Системное тестирование
          system_testing_describe: Высокоуровневая проверка функционала всей программы или системы в целом. Или проще говоря проверяется система, платформа или окружение где должно работать то или иное ПО.
          performance_testing: Тестирование производительности
          performance_testing_describe: <p>Тестирование, которое проводится с целью определения, как быстро работает система или её часть под определённой нагрузкой.</p><ul><li><b>Нагрузочное тестирование (load testing)</b></li></ul><p>Тестирование предназначено для проверки работоспособности системы при стандартных нагрузках и для определения максимально возможного пика, при котором система работает правильно.</p><ul><li><b>Стресс тестирование (stress testing)</b></li></ul><p>Тестирование предназначено для проверки работоспособности системы при <i>не</i>стандартных нагрузках и для определения максимально возможного пика, при котором система работает правильно. Так же предназначено для выявления результатов, при которых система переходит в нерабочее состояние.</p>
          regression_testing: Регрессионное тестирование
          regression_testing_describe: Регрессионное тестирование проводится с целью проверить, не влияют ли новые функции, улучшения и исправленные дефекты на существующую функциональность продукта и не возникают ли старые дефекты.
          unit_testing: Модульное тестирование
          unit_testing_describe: Каждая сложная программная система состоит из отдельных частей - модулей, выполняющих ту или иную функцию в составе системы. Для того, чтобы удостовериться в корректной работе всей системы, необходимо вначале протестировать каждый модуль системы по отдельности. В случае возникновения проблем при тестировании системы в целом это позволяет проще выявить модули, вызвавшие проблему, и устранить соответствующие дефекты в них. Такое тестирование модулей по отдельности получило называние модульного тестирования.
          security_testing: Тестирование безопасности
          security_testing_describe: Тестирование безопасности - это стратегия тестирования, используемая для проверки безопасности системы, а также для анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным.
          localization_testing: Тестирование локализации
          localization_testing_describe: Тестирование локализации - это процесс тестирования локализованной версии программного продукта. Проверка правильности перевода элементов интерфейса пользователя, проверка правильности перевода системных сообщений и ошибок, проверка перевода раздела "Помощь"/"Справка" и сопроводительной документации.
          usability_testing: Юзабилити тестирование
          usability_testing_describe: Тестирование удобства пользования - это метод тестирования, направленный на установление степени удобства использования, обучаемости, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий. Выявлять проблемы, связанные со специфическим механизмом интерфейса определять, существуют ли проблемы с удобностью интерфейса для навигации, использования основного функционала.

      tab_who_are_qa:
        tab: Кто такие QA?
        head: QA - не професия, a вдохновение и вечное совершенствование!
        describe: "Работа Quality Assurance engineer заключается скорее всего в контроле за правильным выполнением всех этапов разработки и правильной работы итогового продукта. Очень похоже на то за чем следит тестировщик-мануальщик. Но Тестировщик мануальщик проверяет ПО, и по результатам проверки ПО либо принимает его, либо отправляет на доработку, если есть баги или неточности. QA инженер также соблюдает стандарты разработки програм, взаимодейтсвует с множеством людей, таких как: программисты, аналитики, продакт овнеры, заказчики, дизайнеры и т.д., но более тесно. Он буквально залазит в продукт и разбирает его по кусочкам и когда видит в целом что да как, может подсказать или предовратить появление багов, расказав колегам о найденых проблемах."
        describe2: "QA инженер это человек который видит продукт со стороны, внутри, и как стороний наблюдатель который далек от айти. Но для того что бы видеть так нужно много практиковатся и копить опыт."
        responsibilities: "В обязаности тестироващика чаще всего входят:"
        responsibilities_describe: <ul><li>анализ и расчет времени нужного на создание приложения или исправление бага</li><li>процесс тестирования непосредственно</li><li>повторное тестирование моментов в которых ранее были обнаружены проблемы</li><li>разработка сценариев тестирования</li><li>внесение обнаруженных недочетов или багов в трекинговую систему</li><li>обсуждение исправлений с всеми участниками разработки и аналитики</li><li>отслеживание процесса исправления</li><li>анализ результатов тестирований</li><li>доработка сценариев</li><li>ведение документации по тестам</li><li><a href="#" onclick="document.querySelector('#icon-web').click()">Написанием автотестов на GUI</a></li><li><a href="#" onclick="document.querySelector('#icon-back').click()">Написанием тестов на API</a></li><li><a href="#" onclick="document.querySelector('#icon-mobile').click()">Написанием тестов на Mobile</a></li></ul>

      tab_misconceptions: Проверка заблуждений
      tab_gui: Что такое GUI тестирование?
      tab_api: Что такое Api тестирование?
      tab_mobile: Что такое Mobile тестирование?

  tests:
    gui:
      ruby:
        native:
          header: Написание простых теста с помощью Ruby + Selenium
          tutorial: Для написания автотестов на Ruby, предпологается что у вас в системе установлено необходимое програмное обеспечение для этого. Если нет нажмите <a href='#' onclick="click_install_menu()">сюда</a>.<br>
          tutorial2: "Для того что бы тесты работали корректно нужно что бы была установлена главная связка програмного обеспечения, а именно: <ul><li>обязательно <a href=\"https://chromedriver.chromium.org/downloads\">chromedriver</a></li></ul> и установленые gems(так называются библиотеки в ruby): <ul><li><strong>selenium-webdriver</strong></li><li><strong>chromedriver-helper</strong></li>"
          tutorial3: "Для установки гемов необходимо открыть терминал или командную строку и написать там две команды:"
          create_test_file: Затем создадим файлик с расширением <strong>rb</strong> в нашем редакторе. Назовем его например <strong>test.rb</strong>, ну или как хотите
          create_test_file2: "Или создайте файлик в терминале (Mac Linux) через команду:"
          create_test_file3: "Или создайте файлик в командной строке (Windows) через команду:"

          code1: Затем напишем простой код открытия страницы и запустим его. В результате у вас откроется страница браузера Google Chrome
          comment1: Объявляем драйвер. Имено эта строка и открывает браузер
          comment2: Задаем гет запрос для драйвера. Это все равно что вы перешли по ссылке в браузере
          comment3: Эта команда означется спать 10 секунд

          code2: Давайте немного перепишем код, в котором будет осуществлятся набор текста в поисковой строке и нажатия на кнопку "Поиск"
          comment4: Глобальная настройка на селеинум в тесте что бы элемент искало до 10 секунд. implicit_wait - неявное ожидание, то есть то ожидание когда программа ждет когда элемент появится на странице
          comment5: Так в нативном селениуме ищется по css-selector (селектору) элемент
          comment6: А так заполняется поле
          comment7: А так на него кликается

          code3: Но проблема кода выше, что он просто прогоняется написаный нами код теста, а было бы неплохо сделать явную проверку (assert), например на количество найденых ссылок на статьи, ну и плюс сделаем все через метод класса. Давайте попробуем сделать это так
          comment8: Так в ruby объявляется класс
          comment9: Так объявляется метод инициализации того, что будет в самую первую очередь выполнено в коде
          comment10: Так объявляется метод который содержит какую-то логику в класе
          comment11: "Ищем все блоки найденных статей. Обратите внимание что метод поиска который ищет элементы (а не один элемент) это: find_elements и с помощью него вернется массив объектов елементов"
          comment12: Так пишется услувие что 10 равно количеству найденых элементов в массиве, в данном случаи это и есть ассерт. Можите поменять 10 на 11 и увидите что командной строке появляется ошибка
          comment13: Так пишется прерывание кода с сообщением, если условние не будет соблюдено
          comment14: Отдельный метод что бы запустить все более менее структурировано. Обратите внимание что там написано self.def - это означает метода экземпляра будет относится к самому объекту
          comment15: Вызов эдиного экземпляра класса

          code4: "Код становится большим, и было бы неплохо его как то декомпозировать или хотя бы разбить на файлы. Для этого создайте 4 файла: <strong>test1.rb</strong>, <strong>test2.rb</strong>, <strong>test3.rb</strong>, <strong>runner.rb</strong>"
          comment16: Объявление модуля. Модули являются контейнерами для классов, методов и констант. Грубо говоря это пространство имен и примесей.
          comment17: Так подключается модуль

          runner: Запускаем код
        rspec:
        cucumber:
    api:
    mobile:
    perfomence:
