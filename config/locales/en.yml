en:
  other: Other
  mac:
    how_install: "- how to install as the main OS"
    ruby:
      recommend: "I recommend installing RVM - ruby version manager for %{platform}. This will require:"
      line1: 1) Open a terminal in %{platform}. Add GPG key <pre class=\"code code-shell-cmd\" title=\"triple click to select command\"> gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0BE739499</pre>
      line2: 2) Run the command <pre class = "code code-shell-cmd" title = "triple click to select command"> \curl -sSL https://get.rvm.io | bash -s stable </pre>
      line3: 3) After installing "rvm" you need to restart the terminal in the shell
      line4: 4) We need to install version 2.7 of Ruby, for this we type and execute the command in the terminal <pre class = "code code-shell-cmd" title = "triple click to select command"> rvm install 2.7 </pre>
      line5: "5) After a long installation, you can also view the version in the terminal by typing and executing the command <pre class = \" code code-shell-cmd \"title = \" triple click to select command \"> ruby -v </pre> "
    java:
      header: Installing the Java Programming Language on MacOsX
      line1: 1) Open terminal in MacOsX and update packages with command
      line2: 2) Run the command
      line3: If for some reason you have problems with the installation, follow the link and give it a try
      line4: "3) After installation, you can view the version by typing and executing the command"
    js:
      header: Установка языка программирования NodeJS на MacOsX
      line1: 1) Откройте терминал в MacOsX и обновите пакеты с помощью команды
      line2: 2) Запустите команду
      line3: Если по какой-то причине у вас возникли проблемы с установкой, перейдите по ссылке и попробуйте
      line4: 3) После установки "Node" необходимо перезапустить терминал в оболочке
      line5: 4) После установки и перезапуска терминала вы можете увидеть версию, набрав и выполнив команду
  fedora:
    snap: All need install from SNAP
    no_snap: All need install from not SNAP
    how_install: "- how to install as the main OS or next to Windows 10"
    java:
      header: Installing the Java programming language on %{platform}
      line1: "1) Open a terminal in Fedora and type the following command"
      line2: "2) As a result, a list of all versions of the JDK (Java Development Kit) will be displayed, you need to select the one depending on which you need, for example"
      line3: "If for some reason you have problems with the installation, go to the link and give it a try."
      line4: "3) After installation, you can view the version by typing and running the command"
    js:
      header: Installing the NodeJs programming language on %{platform}
      step1: Can be installed from Snap
      line1: "1) Open a terminal in Fedora and type the following command"
      line2: "2) As a result, a list of all NodeJS versions will be displayed, you need to select the one depending on which you need, for example"
      line3: "If for some reason you have problems with the installation, go to the link and give it a try."
      line4: "3) After installation, you can view the version by typing and executing the command"
    ruby:

  ubuntu:
    snap: All need install from SNAP
    no_snap: All need install from not SNAP
    how_install: "- how to install as the main OS or next to Windows 10"
    java:
      header: Installing the Java programming language on %{platform}
      line1: "1) Open a terminal in Ubuntu and type the following command"
      line2: "2) As a result, a list of all versions of the JDK (Java Development Kit) will be displayed, you need to select the one depending on which you need, for example"
      line3: "If for some reason you have problems with the installation, go to the link and give it a try."
      line4: "3) After installation, you can view the version by typing and running the command"
    js:
      header: Installing the NodeJs programming language on %{platform}
      step1: Can be installed from Snap
      line1: "1) Open a terminal in Ubuntu and type the following command"
      line2: "2) As a result, a list of all NodeJS versions will be displayed, you need to select the one depending on which you need, for example"
      line3: "If for some reason you have problems with the installation, go to the link and give it a try."
      line4: "3) After installation, you can view the version by typing and executing the command"
    ruby:

  windows:
    how_install: "- how to install as the main OS"
    ruby:
      header: Installing the Ruby programming language on %{platform}
      line1: "1) Go to the <a href='https://rubyinstaller.org/downloads/' target='_blank'> link </a> and download the installation file - preferably version 2.7.3-1, examples indicated on the site will be on this version of Ruby "
      line2: "2) Press the key combination <strong> WIN + R </strong> and enter the command <pre class = \" code code-shell-cmd \"title=\"triple click to select command \"> cmd </pre> - the command line will open "
      line3: "3) You need to check the version of Ruby that is installed, for this we specify the command <pre class = \" code code-shell-cmd \"title=\" triple click to select command \"> ruby -v </pre>"
    java:
      header: Installing the Java programming language on %{platform}
      line1: "1) Follow the link and download the installation file for"
      line2: ", and install the software. Both versions will suit us in the future."
      line3: "2) Press the key combination <strong> WIN + R </strong> and enter the command <pre class = \" code code-shell-cmd \"title = \" triple click to select command \"> cmd </pre> - the command line will open "
      line4: "3) You need to check the Java version that is installed, for this we specify the command <pre class = \" code code-shell-cmd \"title = \" triple click to select command \"> java -version </pre>"
    js:
      header: Installing the NodeJs programming language on %{platform}
      line1: 1) Go to
      line2: link and download the installation file and install the software from it
      line3: "2) Press the key combination <strong> WIN + R </strong> and enter the command <pre class = \" code code-shell-cmd \"title = \" triple click to select command \"> cmd </pre> - the command line will open "
      line4: "3) You need to check if NodeJS was installed correctly, for this we specify the command <pre class = \" code code-shell-cmd \"title = \" triple click to select command \"> node -v </pre>"
    head: Useful software and links for %{platform} that will help with testing and not only
    git: "- a distributed version control system."
    putty: "- freeware client for various remote access protocols, including SSH, Telnet, rlogin."
    fast_stone: "- very cool editor for screenshots, where you can sign and draw"
    sys:
      env1: "How to exhibit"
      env2: "system variables"
      env3: (needed for JAVA)
    docker: "- platform for containerization"
    postman: "- a program for working with api requests"
    zoom: "- a program for video conferencing"
    ssh: "- a description of how to work with private and public ssh keys, generate normal rsa (ssh-keygen -t rsa -b 4096)"
    editor: editor IDE for %{platform}
    zsh: "is an open source community driven ZSH configuration management platform. Roughly a bash add-on. The gnzh plugin."
    terminator: "- very convenient terminal, better than the default one on Ubuntu"
    terminator2: "- very convenient terminal, better than the default one on MacOs"
    libbre: "- everything that is in Microsoft office but only for free"
    homebrew: "- to install third-party packages through the terminal"
    appstorrent: "- a lot of useful software for mac"
    paw: "- a program for working with api requests, an alternative to Postman"
    vpn: "- program for VPN connection"

  see_version: "This will display the %{lang} version:"
  ide: Installing the IDE for Development (Editor)
  feature: In the future, the code will be shown in the %{ide} editor, but you can use any editor you like.
  count: "There are many good editors I use to write code for %{lang}, some of them are:"
  step:
    gui: How to write simple GUI tests
    back: How to write simple API tests
    mobile: How to write simple Mobile tests
  example: Example
  outcome: Outcome
  guide: guide
  or: or
  or_or: version, or for
  outcome_describe: "When you have an installed programming language on the OS and a good editor for your new project, you can safely try your hand at writing a simple or complex test, but first select the section:"

  loader: Loading ...
  hello: Hello world! EN
  header: EN
  language_en: English
  language_ru: Russian
  main: Home
  about: About
  about_describe: "<strong> The purpose of the blog is to help beginners (or non-beginners) QA understand the fundamental concepts, terms and basics in order to start automating software on their own. </strong>"
  author: S.Kievskiy
  gui: "<strong>GUI (Graphical User Interface) or GUI (Graphical User Interface) </strong> is one of the types of user interfaces, the elements of which are made in the form of graphical images. That is, all the main objects present in this interface - icons, function buttons, menu objects, etc. - made in the form of images. If we compare the GUI with the usual command line, then in the first version, the user has full access to absolutely all the elements that he sees on the display. This access can be implemented using different input devices: an optical mouse, trackball, keyboard, joystick, etc. Usually, in the GUI, each graphic object conveys the meaning of a function using an understandable image, so that it is easier for the user to understand certain software and easier to interact with the OS in the whole. But it is important to understand that the GUI is only an integral part of the graphical interface. It functions at the level of data visualization and interacts with the user in the same way."
  cli: <strong>CLI - command line interface</strong> - command line interface, that is, the case when we perform some action using the terminal.
  apis:
    line1: The <strong>API is the Application Programming Interface</strong>, or application programming interface through which one program can communicate with another. The API allows information to be sent directly from one program to another, bypassing the user interface.
    line2: <strong> How does it work?</strong> Imagine that you are sitting in a restaurant, choosing a dish from the menu. A waiter comes up and you place an order. The waiter passes your order to the kitchen, the magic happens there, and after a while the finished dish appears in front of you. The API works on the same principle - it accepts your request, transfers information to the system, processes it and returns a response.
    line3: <strong> What are they? </strong> API can be internal, private - when software components are connected and used within the system. Or it can be open, public - in this case, it allows external users or other programs to receive information that can be integrated into their applications.
    line4: In order for programs to communicate with each other, their API must be built according to a single standard. One of them is REST, a standard for the architecture of the interaction between applications and sites that uses the HTTP protocol. The peculiarity of REST is that the server does not remember the state of the user between requests. In other words, user identification (authorization token) and all parameters of the operation are passed in each request. This approach is so simple and convenient that it has almost supplanted all others.
  mobile: Everything is the same as in the GUI, only the peculiarity of smartphones is that there are many of them and each has its own screen resolution. They have their own applications for their screens and the display of the site in the mobile version is different from the desktop version. Because of this, testing mobile versions and software on mobile phones is considered one of the most difficult.
  installs:
    install: Install
    windows: on Windows
    linux: on Ubuntu
    fedora: on Fedora
    mac: on MacOs
  describe:
    header: About testing in simple words
    tabs_and_page:

      tab_what_is_this_testing:
        tab: What is software testing?
        describe:
          line1: Software testing is the process of verifying that the requirements from the customer and what the programmers wrote.
          line2: The process when we check how it should be and how it really is, we call it - testing.
          line3: Each testing has a life cycle (LC). Not to be confused with development lifecycle or development methodology.
          line4: Lifecycle testing is the stages from the very beginning of testing and finding errors (bugs), inconsistencies, etc., to its end, when all the errors are corrected - when the product meets the terms of reference (TOR) from the customer.
          line5: Most often, in the testing process, additions to the TK arise, since some things, for example, are technically impossible to implement and other implementation options are found so that the task from the TK is performed.
          line6: "Let's consider, so what is the \" Life cycle in testing \"and its stages:"
          line7: 1. <em> Requirements planning and analysis </em> - you just look at what they want from you and say \ "It will take me two days to parse and see what is ready and what is not in the software \". <p>
          line8: 2. <em> Clarification of acceptance criteria </em> - after you have read and looked at the raw functionality, you will definitely clarify the minimum requirements for the software to work. Step is required. <p>
          line9: 3. <em> Clarifying the testing strategy </em> - in principle, you can do without it. But it is important to understand that the strategy in testing is the organization of the testing process itself, subject to limited resources. Therefore, it would be nice to understand what resources are available in general. Plus, a testing strategy is needed so that each of the participants understands what is the role of testing in the project, what is being tested, how it is tested, and so that everyone has a real understanding in anticipation of what is generally going on in quality control. <p>
          line10: "4. <em> Development of test documentation </em> - this is what many automators do not like, this is writing test cases. At this stage, development, revision, test documentation takes place: test case, test suite, test plans <p> "
          line11: 5. <em> Executing test cases and Fixing found defects </em> - speaks for itself. We recorded a step-by-step execution of some small piece of software (test case) and began to test it. Oops! The performed check from the test case does not correspond to what is actually in the software - we write an error in the bug tracking (platform for fixing any bug, task, epik, etc.) <p>
          line12: "6. <em> Analysis of test results and reporting - I will write about this as they write in the Internet: the formulated conclusions depend on the test plan and acceptance criteria and serve as the basis for stages 1, 2, 3 of the next iteration. </em>"
          line13: <em> Planning is a continuous process of making managerial decisions and methodological organization of efforts to implement them in order to ensure the quality of a certain process over a long period of time. In fact, it is your colleagues who gather and discuss some kind of revision - in this case, based on your experience, say that, for example, it will take you two days to test this revision when it is ready. <br> <br> Reporting is collection and dissemination of information on the results of work (including the current status, assessment of progress and forecast of the development of the situation). </em> </blockquote>
          line14: "It all sounds awful and incomprehensible - but this is only for now, when the practice begins, for you everything that is written above will become familiar and understandable. Let's go further!"
          line15: Since there are many approaches in the testing life cycle, in the testing itself we output <a href="#" id="type_testing" onclick=clickTab("#types-qa")> Types of testing </a>

      tab_testing_types:
        tab: Types testing
        describe:
          head: "It is necessary to highlight the main types of testing:"
          functional_testing: Functional testing
          functional_testing_describe: Functionality check (testing by the "black box" method) - checking the compliance of the software with the requirements stated in the specification. Both full testing of the declared functionality and verification of only basic functionality can be carried out. White box testing testing for compliance of a software product with requirements with knowledge of the internal structure of the system implementation (source code and technical specifications are available). Black box testing testing for compliance of a software product with requirements without knowing the internal structure of the system implementation.
          system_testing: System testing
          system_testing_describe: High-level verification of the functionality of the entire program or the system as a whole. Or, more simply, the system, platform or environment is checked where this or that software should work.
          performance_testing: Performance testing
          performance_testing_describe: <p> Testing to determine how quickly a system or part of it performs under a given load.</p><ul><li><b>Load testing</b></li></ul><p>Testing is intended to verify the system's performance under standard loads and to determine the maximum possible peak at which the system operates correctly.</p><ul><li><b>Stress testing </b></li></ul><p>Testing is intended to check the system performance under<i>non</i>standard loads and to determine the maximum possible peak at which the system operates correctly. It is also intended to identify the results in which the system goes into a non-working state.</p>
          regression_testing: Regression testing
          regression_testing_describe: Regression testing is done to check if new features, enhancements, and fixed defects affect the existing functionality of the product, or if old defects arise.
          unit_testing: Unit testing
          unit_testing_describe: Each complex software system consists of separate parts - modules that perform a particular function as part of the system. In order to make sure that the entire system is working correctly, you must first test each module of the system separately. If problems arise during testing the system as a whole, this makes it easier to identify the modules that caused the problem and eliminate the corresponding defects in them. This unit testing is individually called unit testing.
          security_testing: Security testing
          security_testing_describe: Security testing is a testing strategy used to verify the security of a system, as well as to analyze the risks associated with ensuring a holistic approach to protecting an application, hacker attacks, viruses, and unauthorized access to confidential data.
          localization_testing: Localization testing
          localization_testing_describe: Localization testing is the process of testing a localized version of a software product. Checking the correctness of the translation of the user interface elements, checking the correctness of the translation of system messages and errors, checking the translation of the "Help" / "Support" section and accompanying documentation.
          usability_testing: Usability testing
          usability_testing_describe: Usability testing is a testing method aimed at establishing the degree of usability, learnability, comprehensibility and attractiveness to users of the developed product in the context of specified conditions. To identify problems associated with a specific interface mechanism to determine whether there are problems with the usability of the interface for navigation, using the main functionality.

      tab_who_are_qa:
        tab: Who are QA?
        head: QA - is not a profession, but inspiration and eternal improvement!
        describe: "The job of a Quality Assurance engineer is most likely to control the correct execution of all stages of development and the correct operation of the final product. It is very similar to what a manual tester monitors. for revision, if there are bugs or inaccuracies. The QA engineer also adheres to the standards of software development, interacts with many people, such as programmers, analysts, product owners, customers, designers, etc., but more closely. He literally climbs into the product and takes it apart piece by piece, and when he sees in general what and how, he can prompt or prevent the appearance of bugs by telling colleagues about the problems found. "
        describe2: "A QA engineer is a person who sees the product from the outside, inside, and as an outside observer who is far from IT. But in order to see so much you need to practice and gain experience."
        responsibilities: "The responsibilities of a tester most often include:"
        responsibilities_describe: <ul> <li> analysis and calculation of the time required to create an application or fix a bug </li> <li> testing process directly </li> <li> re-testing moments in which problems were previously found </li> <li> development of test scripts </li> <li> introduction of discovered defects or bugs into the tracking system </li> <li> discussion of fixes with all development and analytics participants </li> <li> tracking the fix process </li> <li> analysis of test results </li> <li> script revision </li> <li> test documentation </li><li> <a href = "#" onclick = "document.querySelector('#icon-web').click() "> Writing GUI autotests </a> </li> <li> <a href="#" onclick="document.querySelector('#icon-back').click()"> Writing API tests </a> </li> <li> <a href="#" onclick="document.querySelector('#icon-mobile').click()"> Writing Mobile Tests </a> </li> </ul>

      tab_misconceptions: Testing misconceptions
      tab_gui: What is GUI testing?
      tab_api: What is API testing?
      tab_mobile: What is Mobile testing?

  tests:
    gui:
      ruby:
        native:
          header: Writing Simple Test With Ruby + Selenium
          tutorial: To write autotests in Ruby, it is assumed that you have the necessary software installed on your system. If not click <a href='#' onclick="click_install_menu()"> here </a>. <br>
          tutorial2: "In order for the tests to work correctly, the main bundle of software must be installed, namely: <ul> <li> required <a href=\"https://chromedriver.chromium.org/downloads\"> chromedriver </a> </li> </ul> and installed gems (this is how libraries are called in ruby): <ul><li><strong>selenium-webdriver</strong></li><li> <strong> chromedriver-helper </strong> </li> "
          tutorial3: "To install gems, you need to open a terminal or command line and write two commands there:"
          create_test_file: Then create a file with the extension <strong> rb </strong> in our editor. Let's call it for example <strong> test.rb </strong>, or whatever you want
          create_test_file2: "Or create a file in the terminal (Mac Linux) using the command:"
          create_test_file3: "Or create a file in the command line (Windows) using the command:"

          code1: Then we write a simple code for opening the page and run it. This will open the Google Chrome browser page.
          comment1: We declare the driver. It is this line that opens the browser.
          comment2: We set a get request for the driver. It's like you followed a link in a browser.
          comment3: This command is meant to sleep 10 seconds

          code2: Let's rewrite the code a little, in which we will type in the search bar and click on the "Search" button
          comment4: Global setting for seleinum in the test so that the element would be searched for up to 10 seconds. implicit_wait - implicit wait, that is, the wait when the program waits for the element to appear on the page
          comment5: This is how the native selenium searches for an element by css-selector
          comment6: And this is how the field is filled
          comment7: And this is how it clicks

          code3: But the problem with the code above is that it simply runs the test code we have written, but it would be nice to make an explicit check (assert), for example, on the number of links to articles found, and plus we will do everything through the class method. Let's try to do it like this
          comment8: This is how a class is declared in ruby
          comment9: This is how the initialization method is declared for what will be done in the first place in the code
          comment10: This is how a method is declared that contains some logic in the class
          comment11: "We are looking for all the blocks of found articles. Please note that the search method that searches for elements (not a single element) is: find_elements and it will return an array of element objects"
          comment12: This is how the condition is written that 10 is equal to the number of found elements in the array, in this case it is assertion. You can change 10 to 11 and you will see that the command line shows an error
          comment13: This is how the code interrupt is written with a message if the condition is not met
          comment14: A separate method to run everything more or less structured. Note that it says self.def - this means the instance method will refer to the object itself
          comment15: self - reference to the class instance in the methods of the class instance

          code4: "The code is getting big, and it would be nice to decompose it somehow or at least split it into files. To do this, create 4 files: <strong> test1.rb </strong>, <strong> test2.rb </strong>, <strong> test3.rb </strong>, <strong> runner.rb </strong> "
          comment16: Module declaration. Modules are containers for classes, methods, and constants. Roughly speaking, this is a namespace and mixins.
          comment17: This is how the module is connected

          runner: Run the code
        rspec:
        cucumber:
    api:
    mobile:
    perfomence: